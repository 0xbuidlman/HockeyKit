Definitionen:

Allgemein:
- Apps: fuer jede Art von Datei in einem Verzeichnis, gilt immer die 1. gefundene pro Dateiendung
- iOS: Apps groesser 20MB koennen nicht per OTA installiert werden, d.h. bei nicht Desktop Browser kein Install button, sondern hinweis auf Groesse und Verweis auf Desktop installation
- Client Erkennung:
Browser:
User Agent beinhaltet (eines von):
"iPad" + "OS 4": iPad Grid layout
"iPad": Hinweis Text zum Aufrufen der Webseite auf dem Desktop oder Upgrade of iOS 4.x
"iPhone" + "iPhone OS 4": iPhone Layout, Grid am Anfang wenn mehrere Apps vorhanden sind
"iPhone": Hinweis Text zum Aufrufen der Webseite auf dem Desktop oder Upgrade of iOS 4.x
"Android": Android Layout, Grid am Anfang wenn mehrere Apps vorhanden sind
und NICHT:
"CFNetwork": iOS Client
"Hockey/iOS": iOS Client
"Hockey/Android": Android Client

iOS Client:
User Agent beinhaltet (eines von):
"CFNetwork": iOS Client
"Hockey/iOS": iOS Client

Android Client:
User Agent beinhaltet:
"Hockey/Android": Android Client


Apps ohne Versionen:
- Mandatory:
-- Pro app ein Unterverzeichnis mit dem namen des bundle identifiers (iOS) oder des reverse url (Android)
-- Pro iOS app: je eine .ipa und .plist (Standard Apple iOS distribution Files)
-- Pro Android app: je eine .apk (Standard Android app package) und .json
-- Android .json Struktur:
{
	"title":app title,
	"versionCode":build number,
	"versionName":version string
}
- Optional:
- Pro iOS app eine .mobileprovision Datei, wird nur im Web Interface verwendet und angezeigt (iOS only !)
- Pro app ein .png Datei, mit App Icon
- Pro app ein .html Datei mit Release notes
- Pro app mehrere laenderspezifische .html.laendercode (de, en. fr, ...) Release notes, es muss immer eine Release notes ohne laendercode geben, welche die Default darstellt und im Web benutzt wird, oder wenn im Client fuer den uebergebenen laendercode keine gefunden wurde (iOS only !)
- Pro app eine "private" Datei, welche die Datei vom globalen Web Interface ausschliesst (iOS only !)
- Pro app eine .team Datei, welche den Zugriff auf die Version auf angegebene Teams eingrenzt, Match mit /stats/userlist.txt Inhalt, bedeutet kompletten Ausschluss vom Web Interface, falls der Inhalt "sinnvoll" ist (iOS only !)

Apps mit Versionen:
- Pro app mehrere Unterverzeichniss pro Version, Name endet mit Versionsnummer, gemeinsamer willkuerlicher Namensbeginn, z.b. abhcj1.1, abhcj2.0, ...
- .png, .mobileprovision, .icon Dateien liegen weiterhin im App Verzeichnis und NICHT in den Versionen
- Versionsverzeichnisse enhalten die mandatory Dateien und Release notes Datei(en)


Statistik:
- Ist optional im /stats/ Unterverzeichnis
- Installationen werden in einer Datei pro bundleidentifier abgelegt, Format:
UDID;;DeviceType;;OSVersion;;AppVersion;;Timestamp;;Laendercode
(Laendercode optional)
- Mapping von UDID zu Users und Team zugehoerigkeit von Users/Devices in userlist.xtx, Format:
UDID;Name;Comma separated list von Teamnamen
(Teamnamen sind optional)


API Definitionen:
1) Eingabe:
Parameter: keine
App Type: iOS, Android
Client: Browser

Ausgabe:
- Webseite, angepasst auf aufrufenden Browser (siehe Javascript am Ende von index.php)
- keine private deklarierten Versionen (iOS only)


2) Eingabe:
Parameter: 
    bundleidentifier
App Type: iOS, Android
Client: Browser

Ausgabe:
- pruefe ob das Verzeichnis existiert und User Agent (iOS, Android, Desktop) abhaengig eine App (Version) vorhanden ist, welche nicht private ist, wenn ja, zeige diese App mit Layout von 1) an
- falls nicht, zeige einen Text an, a la "Es gibt hier nichts zu sehen"


3) Eingabe:
Parameter: 
    bundleidentifier
    udid (optional)
    version (optional = appversion)
    ios (optional = os version)
    platform (optional = device type)
App Type: iOS
Client: iOS Client
API Version: 1 (api parameter nicht angegeben oder = 1)

Ausgabe:
- pruefe ob das Verzeichnis existiert und eine App (Version) vorhanden ist, welche nicht private ist oder fuer die UDID erlaubt ist (match ueber team und userlist falls vorhanden), liefer JSON result zurueck, ansonsten JSON Result mit Fehler
- falls, udid, version, ios, platform vorhanden, protokolliere daten in /stats/bundleidentifier mit aktuellem Zeitstempel

JSON Result mit Fehler:
- { result: "-1" }

JSON Result mit Ergebnis:
- {"notes":release notes,"title":app title,"result":version number}


4) Eingabe:
Parameter: 
    bundleidentifier
    api = 2
    udid
    version ( = appversion)
    os ( = os version)
    platform ( = device type)
    lang ( = 2 digit laendercode sprache)
App Type: iOS
Client: iOS Client
API Version: 2

Ausgabe:
- pruefe ob das Verzeichnis existiert und eine App (Version) vorhanden ist, welche nicht private ist oder fuer die UDID erlaubt ist (match ueber team und userlist falls vorhanden), liefer JSON result zurueck, ansonsten JSON Result mit Fehler
- falls, udid, version, ios, platform vorhanden, protokolliere daten in /stats/bundleidentifier mit aktuellem Zeitstempel, lang variable optional am Ende falls vorhanden

JSON Result mit Fehler:
- { result: "-1" }

JSON Result mit Ergebnis:
- [{"notes":release notes,"title":app title,"result":version number}, {"notes":release notes,"title":app title,"result":version number}, ...]
- Sortierung, von Neu nach Alt (String sortierung der Versionsnummer)


5) Eingabe:
Parameter: 
    bundleidentifier
    api = 2
App Type: Android
Client: Android Client
API Version: 2

Ausgabe:
- pruefe ob das Verzeichnis existiert und eine App (Version) vorhanden ist, liefer JSON result zurueck, ansonsten JSON Result mit Fehler

JSON Result mit Fehler:
- { result: "-1" }

JSON Result mit Ergebnis:
- [{"notes":release notes,"title":app title,"result":version number}, {"notes":release notes,"title":app title,"result":version number}, ...]
- Sortierung, von Neu nach Alt (String sortierung der Versionsnummer)




6) Eingabe:
Parameter:
    bundleidentifier
    type = profile
App Type: iOS
Client: Browser

Ausgabe:
- pruefe ob das Verzeichnis existiert und eine .ipa, .plist und .mobileprovision Datei vorhanden ist, wenn ja, sende die .mobileprovision mit content-type Octet-stream zurueck


7) Eingabe:
Parameter:
    bundleidentifier
    type = app
App Type: iOS
Client: Browser, iOS Client

Ausgabe:
- pruefe ob das Verzeichnis existiert und eine .ipa und .plist Datei vorhanden ist, wenn ja, passe die .plist an (__URL__ und icon link einfuegen wenn icon vorhanden ist) und sende diese mit content-type Octet-stream zurueck


8) Eingabe:
Parameter:
    bundleidentifier
    type = ipa
App Type: iOS
Client: Browser, iOS Client

Ausgabe:
- pruefe ob das Verzeichnis existiert und eine .ipa und .plist Datei vorhanden ist, wenn ja, sende die .ipa Datei mit content-type Octet-stream zurueck (send chunk by chunk, to make it work with bigger file sizes)


9) Eingabe:
Parameter:
    bundleidentifier
    type = apk
App Type: Android
Client: Browser, Android Client

Ausgabe:
- pruefe ob das Verzeichnis existiert und eine .apk und .json Datei vorhanden ist, wenn ja, sende die .apk Datei mit content-type Octet-stream zurueck (send chunk by chunk, to make it work with bigger file sizes)


10) Eingabe:
Parameter:
    bundleidentifier
    api = 2
    type = authorize
    udid
    version ( = appversion)
App Type: iOS
Client: iOS Client
API Version: 2

Ausgabe:
- pruefe ob das Verzeichnis existiert und eine .ipa und .plist Datei vorhanden ist
- pruefe ob das HOCKEY_AUTH_SECRET definiert ist
- Berechne den authentifizierungscode via: md5(HOCKEY_AUTH_SECRET . $version. $bundleidentifier . $udid)

JSON Result mit Fehler:
- { authcode: "-1" }

JSON Result bei Erfolg:
- { authcode: aktivierungscode }


